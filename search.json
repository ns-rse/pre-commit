[
  {
    "objectID": "index.html#view-these-slides",
    "href": "index.html#view-these-slides",
    "title": "Pre-commit : Protecting your future self",
    "section": "View these slides‚Ä¶",
    "text": "View these slides‚Ä¶\n\nns-rse.github.io/pre-commit/\n\nYou can scan this QR code and it will take you to these slides or you can visit the site they are hosted at by going to ns-rse.github.io/pre-commit/"
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Pre-commit : Protecting your future self",
    "section": "Introduction",
    "text": "Introduction\n\nResearch Software Engineer at University of Sheffield\nBackground : Statistical Genetics, Medical Statistics and Data Scientist for Telematics Company\nBlog Post (2022-10-10) : pre-commit : Protecting your future self\n\n\n\nGood afternoon, my name is Neil Shephard and I‚Äôm a Research Software Engineer at the University of Sheffield.\n\n\nI‚Äôd like to thank Gavin for inviting me to come and talk to you all about pre-commit, which is an amazing tool I discovered and blogged about, you can read the original article by scanning the QR code, but to give you a little time to do that I‚Äôll just give a very brief overview of my background and experience as I‚Äôve only worked as a Research Software Engineer for just over a year and matured into this role after a convoluted career pathway via Statistical Genetics, Medical Statistics during which I developed a keen interest in reproducible research and started using Git.\nPrior to starting in my current role I spent a few years as a Data Scientist at a telematics company where I didn‚Äôt really do much data science but did learn Python, working collaboratively with Git and good practices for software development and engineering."
  },
  {
    "objectID": "index.html#structure",
    "href": "index.html#structure",
    "title": "Pre-commit : Protecting your future self",
    "section": "Structure",
    "text": "Structure\n\n(Very) brief Git version control.\nA digression into Linting and Testing.\nGit Hooks.\npre-commit installation.\npre-commit configuration.\npre-commit usage.\npre-commit in CI/CD.\n\n\nIn this talk I‚Äôll give a very brief overview of using Git for version control before making a digression into linting and testing. We‚Äôll then look at Git Hooks because they underpin the functionality of pre-commit and I‚Äôll then go through installing and configuring pre-commit, hopefully give a demonstration that won‚Äôt fail and then show how pre-commit can be integrated into Continuous Integration and Delivery pipelines."
  },
  {
    "objectID": "index.html#git",
    "href": "index.html#git",
    "title": "Pre-commit : Protecting your future self",
    "section": "Git",
    "text": "Git\n\nxkcd (1597)https://xkcd.com/1597/\n\nOk, Git is pretty popular but could I have a show of hands for how many people are familiar with and use Git on a daily basis please?\nPause\nGreat, looks like most of the audience are familiar with Git and hopefully are a little more proficient than the XKCD protagonists."
  },
  {
    "objectID": "index.html#git-workflow",
    "href": "index.html#git-workflow",
    "title": "Pre-commit : Protecting your future self",
    "section": "Git Workflow",
    "text": "Git Workflow\n\n\n\n\n\n%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'showBranches': true,'showCommitLabel': true, 'rotateCommitLabel': true}} }%%\ngitGraph\n    commit\n    commit\n    branch bug1\n    checkout main\n    commit\n    checkout bug1\n    commit\n    commit\n    checkout main\n    branch bug2\n    checkout bug2\n    commit\n    commit\n    checkout bug1\n    commit\n    checkout main\n    merge bug1 tag: \"v0.1.1\"\n    checkout bug2\n    commit\n    commit\n    checkout main\n    merge bug2 tag: \"v0.1.2\"\n    commit\n\n\n\n\n\n\n\n\n\nA typical workflow of a version controlled directory is shown here\n\nMake a branch from main to add a feature and here we have two features being developed.\nEdit some files on each branch\nStaging and commit changes as you go, then when ready you.\nPush the changes to the remote origin such as GitHub or GitLab\nMake a pull request to merge these changes into the main branch.\nIf you‚Äôre lucky you won‚Äôt have any merge conflicts. and once approved\nOnce approved and merged another commit is made marking the inclusion of the changes and a tag can optionally be applied.\n\nThis gives us an overview of the Git development cycle and how commits fit in. We‚Äôll move now on to linting and testing."
  },
  {
    "objectID": "index.html#linting-and-testing",
    "href": "index.html#linting-and-testing",
    "title": "Pre-commit : Protecting your future self",
    "section": "Linting and Testing",
    "text": "Linting and Testing\nA digression‚Ä¶\n\nGood practice to lint code & conform to Style Guides\nGood practice to have tests in place for code.\n\n\nLinting - What is all the fluff about?\n\nWhen writing code and it is good practice to lint your code to ensure it conforms to the languages style guides. These are useful because if code is written in a consistent style it makes it easier for multiple people, including your future self to read and understand.\nSimilarly it is sensible, and some would argue essential, to write tests to ensure that your functions, methods and classes work as expected. These tests are run regularly against your code base as it is developed to ensure that changes made to the code don‚Äôt break functionality.\nOften these will be run as you write your code and as part of the Continuous Integration pipelines."
  },
  {
    "objectID": "index.html#a-simple-python-function",
    "href": "index.html#a-simple-python-function",
    "title": "Pre-commit : Protecting your future self",
    "section": "A simple Python function",
    "text": "A simple Python function\nsample.py\nimport numpy as np\n\nfrom pathlib import Path\n\ndef find_files(file_path: Union[str, Path], file_ext: str) -> List:\n    \"\"\"Recursively find files of the stated type along the given file path.\"\"\"\n    # We have a really long comment on this line just for demonstration purposes so that we can generate a few errors that need linting\n    try:\n        return list(Path(file_path).rglob(f\"*{file_ext}\"))\n    except:\n        raise\n\nIn order to explain how pre-commit works I need an example so I‚Äôve created this very simple Python function.\nYou don‚Äôt need to be too familiar with Python to understand and follow along but a quick explanation is that a few libraries are imported, then the function find_files is defined, it takes two arguments a file path and a file extension and it will recursively find all files ending with the given extension along that path, and if an exception is encountered it is raised."
  },
  {
    "objectID": "index.html#a-simple-test",
    "href": "index.html#a-simple-test",
    "title": "Pre-commit : Protecting your future self",
    "section": "A Simple Test",
    "text": "A Simple Test\ntest_sample.py\nfrom .sample import find_files\n\ndef test_find_files():\n    \"\"\"Test the find_files() function\"\"\"\n    py_files = find_files(file_path=\"./\", file_ext=\".py\")\n    assert isinstance(py_files, list)\n    assert \"sample.py\" in py_files\n\nI‚Äôm a big fan of tests and so in addition to writing my function I‚Äôve written a test to make sure my find_files function works as expected.\nIt imports the function and uses it to look in the current directory for files with the extension .py saving the results to py_files. The type of this is checked and it should be a list and then a check is made for the presence of the file sample.py in that list is made."
  },
  {
    "objectID": "index.html#linting-and-testing-tools",
    "href": "index.html#linting-and-testing-tools",
    "title": "Pre-commit : Protecting your future self",
    "section": "Linting and Testing Tools",
    "text": "Linting and Testing Tools\n\nblack PEP8 compliance.\nflake8 PEP8 compliance.\npylint PEP8 compliance, code smells and refactoring suggestions.\npytest\n\n\nWe‚Äôve got some sample code but it might not meet the style guides.\nStyle guides set out a consistent way to write and structure code and there are guides for different languages and sometimes even different styles within a language.\nFor Python there is the PEP8 style guide and there are a number of tools that help with linting Python code to be compliant with PEP8 such as black which mostly applies formatting, flake8 and pylint which check formatting and also look for code smells where poor design patterns have been used and make refactoring suggestions.\nThen there is the pytest framework for writing and running tests which I can highly recommend along with many of its extensions, although you could easily use the standard library unittest too if you wanted to make your life more difficult, really use pytest it saves you time and effort."
  },
  {
    "objectID": "index.html#linting-and-testing-manually",
    "href": "index.html#linting-and-testing-manually",
    "title": "Pre-commit : Protecting your future self",
    "section": "Linting and Testing manually‚Ä¶",
    "text": "Linting and Testing manually‚Ä¶\nblack sample.py\nflake8 sample.py\npylint sample.py\npytest test_sample.py\n\nWe have some code then our sample.py and our test_sample.py, but what does the process of linting them manually look like and how does our code measure up?"
  },
  {
    "objectID": "index.html#linting-manually",
    "href": "index.html#linting-manually",
    "title": "Pre-commit : Protecting your future self",
    "section": "Linting manually",
    "text": "Linting manually\nblack\n‚ù± black sample.py\nAll done! ‚ú® üç∞ ‚ú®\n1 file changed.\nflake8\n‚ù± flake8 sample.py\nsample.py:1:1: D100 Missing docstring in public module\nsample.py:1:1: F401 'numpy as np' imported but unused\nsample.py:2:1: F401 'pandas as pd' imported but unused\nsample.py:7:36: F821 undefined name 'Union'\nsample.py:7:73: F821 undefined name 'List'\nsample.py:8:80: E501 line too long (87 > 79 characters)\nsample.py:9:80: E501 line too long (135 > 79 characters)\nsample.py:12:5: E722 do not use bare 'except'\npylint\n‚ù± pylint sample.py\n************* Module sample\nsample.py:9:0: C0301: Line too long (135/120) (line-too-long)\nsample.py:1:0: C0114: Missing module docstring (missing-module-docstring)\nsample.py:7:35: E0602: Undefined variable 'Union' (undefined-variable)\nsample.py:7:72: E0602: Undefined variable 'List' (undefined-variable)\nsample.py:12:4: W0706: The except handler raises immediately (try-except-raise)\nsample.py:4:0: C0411: standard import \"from pathlib import Path\" should be placed before \"import numpy as np\" (wrong-import-order)\nsample.py:1:0: W0611: Unused numpy imported as np (unused-import)\nsample.py:2:0: W0611: Unused pandas imported as pd (unused-import)\n\n-------------------------------------\nYour code has been rated at -10.00/10\npytest\n‚ù± pylint test_sample.py\n================= test session starts =================\nplatform linux -- Python 3.7.11, pytest-7.1.1, pluggy-1.0.0\nrootdir: /home/neil/work/projects/pre-commit/assets/python\nplugins: hydra-core-1.2.0, regtest-1.5.0, cov-3.0.0\ncollected 0 items / 1 error\n\n======================= ERRORS ========================\n___________ ERROR collecting test_sample.py ___________\ntest_sample.py:1: in <module>\n    from .sample import find_files\nsample.py:7: in <module>\n    def find_and_load_files(file_path: Union[str, Path], file_type: str):\nE   NameError: name 'Union' is not defined\n================ short test summary info ===============\nERROR test_sample.py - NameError: name 'Union' is not defined\n!!!!!!!! Interrupted: 1 error during collection !!!!!!!!\n=================== 1 error in 0.49s ==================="
  },
  {
    "objectID": "index.html#then-you-can-commit-and-push",
    "href": "index.html#then-you-can-commit-and-push",
    "title": "Pre-commit : Protecting your future self",
    "section": "‚Ä¶then you can commit and push",
    "text": "‚Ä¶then you can commit and push\n\n\nGit work cycles encourages regular saving of work, by staging and committing work into Git. Periodically you should Git push to your remote repository ensure your work is backed up just in case of fires or your hard drive failing.\nBut the process of repeatedly linting and testing your code quickly becomes tedious and you may even forget to do so before making commits. This means there is potential for errors to creep into the code base if these steps aren‚Äôt undertaken.\nWhat can we do to mitigate this?"
  },
  {
    "objectID": "index.html#automate-with-pre-commit",
    "href": "index.html#automate-with-pre-commit",
    "title": "Pre-commit : Protecting your future self",
    "section": "Automate with pre-commit",
    "text": "Automate with pre-commit\n\nUses Git Hooks to run checks automatically.\nWritten in Python but hooks for most languages.\nLarge number of supported hooks available to use.\nSupports : C, C++, R, Java, JavaScript, PHP, LISP, Markdown, Go, Bash, Ansible, Docker, Lua, Jupyter Notebooks and more.\n\n\nThis is where pre-commit comes in handy. It uses Git Hooks to run checks automatically.\nIt‚Äôs written in Python but beyond installing pre-commit you don‚Äôt need to know or use Python yourself to use pre-commit as there are a large number of existing pre-commit hooks that are available to be used off the shelf for a whole array of common and not so common languages.\nSo far I think the only thing that I use which I‚Äôve not been able to find a hook for is checking formatting of Org-mode files."
  },
  {
    "objectID": "index.html#what-are-hooks",
    "href": "index.html#what-are-hooks",
    "title": "Pre-commit : Protecting your future self",
    "section": "What are Hooks?",
    "text": "What are Hooks?\n\nActions that are run prior to or in response to a given action.\n\n‚ù± ls -lha .git/hooks\ndrwxr-xr-x neil neil 4.0 KB Mon Oct 24 10:26:37 2022 ÔÑï .\ndrwxr-xr-x neil neil 4.0 KB Tue Jan  3 18:48:37 2023 ÔÑï ..\n.rwxr-xr-x neil neil 478 B  Sun Aug 14 13:35:27 2022 Ôíâ applypatch-msg.sample\n.rwxr-xr-x neil neil 896 B  Sun Aug 14 13:35:27 2022 Ôíâ commit-msg.sample\n.rwxr-xr-x neil neil 4.6 KB Sun Aug 14 13:35:27 2022 Ôíâ fsmonitor-watchman.sample\n.rwxr-xr-x neil neil 189 B  Sun Aug 14 13:35:27 2022 Ôíâ post-update.sample\n.rwxr-xr-x neil neil 424 B  Sun Aug 14 13:35:27 2022 Ôíâ pre-applypatch.sample\n.rwxr-xr-x neil neil 1.6 KB Sun Aug 14 13:35:27 2022 Ôíâ pre-commit.sample\n.rwxr-xr-x neil neil 416 B  Sun Aug 14 13:35:27 2022 Ôíâ pre-merge-commit.sample\n.rwxr-xr-x neil neil 1.3 KB Sun Aug 14 13:35:27 2022 Ôíâ pre-push.sample\n.rwxr-xr-x neil neil 4.8 KB Sun Aug 14 13:35:27 2022 Ôíâ pre-rebase.sample\n.rwxr-xr-x neil neil 544 B  Sun Aug 14 13:35:27 2022 Ôíâ pre-receive.sample\n.rwxr-xr-x neil neil 1.5 KB Sun Aug 14 13:35:27 2022 Ôíâ prepare-commit-msg.sample\n.rwxr-xr-x neil neil 2.7 KB Sun Aug 14 13:35:27 2022 Ôíâ push-to-checkout.sample\n.rwxr-xr-x neil neil 3.6 KB Sun Aug 14 13:35:27 2022 Ôíâ update.sample\n\npre-commit is a hook, but what is a hook?\nWell hooks are actions that are run prior to or in response to a given action that you‚Äôve performed.\nWhen you initialise a Git repository locally a number of sample hooks installed under the .git/hooks/ directory. If you‚Äôve cloned a repository then these .git directory generally aren‚Äôt included so you won‚Äôt have these.\nThis is a directory listing and you can see there are a number of different stages at which hooks might apply, but as the name of this talk gives away, the key hook of interest here is the pre-commit hook.\nEach of these files are Bash scripts and you could sit down and craft your own script to undertake all the tasks you wish to run prior to making commits.\nBut pre-commit saves you a bunch of time thanks to the hooks it makes available, all you need to do is configure it."
  },
  {
    "objectID": "index.html#installation-of-pre-commit",
    "href": "index.html#installation-of-pre-commit",
    "title": "Pre-commit : Protecting your future self",
    "section": "Installation of pre-commit",
    "text": "Installation of pre-commit\n\n\nPython\n‚ù± workon a_virtual_env  # Optional\n‚ù± pip install pre-commit\nConda Environment\n‚ù± conda activate conda_env\n‚ù± conda install -c \\\n        conda-forge pre-commit\n\nGNU/Linux\n# Arch\n‚ù± pacman -Syu python-pre-commit\n# Gentoo\n‚ù± emerge -av pre-commit\n# Debian/Ubuntu\n‚ù± sudo apt install pre-commit\nOSX\n‚ù± sudo port install pre-commit\n‚ù± brew install pre-commit\n\n\n\nI mentioned earlier that you didn‚Äôt really need to know or use Python which was mostly true but you do need to install pre-commit this can be done using pip the Python tool for installing Python packages from the Python Package Index and you can optionally do this within a virtual environment or Conda Environment if you use Conda to manage your virtual environments.\nIf you use GNU/Linux then many package managers have pre-commit available in the package repositories to install and some examples of how to install the relevant packages under Arch, Gentoo and Ubuntu are shown.\nThe OSX package managers macports and homebrew also includes pre-commit so you can install with either of those."
  },
  {
    "objectID": "index.html#pre-commit-config.yaml",
    "href": "index.html#pre-commit-config.yaml",
    "title": "Pre-commit : Protecting your future self",
    "section": ".pre-commit-config.yaml",
    "text": ".pre-commit-config.yaml\nRoot of a project under Git version control.\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0\n    hooks:\n      - id: trailing-whitespace\n        types: [file, text]\n      - id: end-of-file-fixer\n        types: [file, text]\n      - id: check-docstring-first\n      - id: check-case-conflict\n      - id: check-yaml\n  - repo: https://github.com/psf/black\n    rev: 22.10.0\n    hooks:\n      - id: black\n        types: [python]\n        additional_dependencies: ['click==8.0.4']\n        args: [\"--config pyproject.toml\"]\n  - repo: https://github.com/pycqa/flake8.git\n    rev: 5.0.4\n    hooks:\n      - id: flake8\n        args: [\"--config setup.cfg\"]\n        additional_dependencies: [flake8-print]\n        types: [python]\n  - repo: local\n    hooks:\n      - id: pylint\n        args: [\"--rcfile=.pylintrc\"]\n        name: Pylint\n        entry: python -m pylint\n        language: system\n        files: \\.py$\n  - repo: local\n    hooks:\n      - id: pytest\n        name: pytest\n        entry: pytest --cov\n        language:system\nSome extra lines in here\n\nOnce you‚Äôve installed pre-commit you need to configure it.\nConfiguration of pre-commit is via a YAML file called .pre-commit-config.yaml and this should reside in the root of a project that is under Git version control.\nThe top-level defines repos: and you then enable and configure each of the pre-commit hooks you wish to use under its own - repo section.\nIt then has configuration to use other people‚Äôs pre-commit hooks, in this example the black, flake8 and two local hooks that run pylint and pytest.\nLets take a look at how a pre-commit hook is configured."
  },
  {
    "objectID": "index.html#hook-configuration---pre-commit",
    "href": "index.html#hook-configuration---pre-commit",
    "title": "Pre-commit : Protecting your future self",
    "section": "Hook configuration - pre-commit",
    "text": "Hook configuration - pre-commit\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0  # Use the rev you want to point at\n    hooks:\n      - id: trailing-whitespace\n        types: [file, text]\n      - id: end-of-file-fixer\n        types: [file, text]\n      - id: check-docstring-first\n      - id: check-case-conflict\n      - id: check-yaml\n\nThis is the main pre-commit hooks repository configuration, it defines the repository from which a particular version of a virtual environment is downloaded and you specify a revision of this to use.\nA series of hooks are then defined, here the trailing-whitespace and end-of-file-fixer are enabled to run on files of type text. There are then checks for docstring-first, case-conflict and finally a check-yaml hook which makes sure any YAML files are correctly formatted."
  },
  {
    "objectID": "index.html#hook-configuration---black",
    "href": "index.html#hook-configuration---black",
    "title": "Pre-commit : Protecting your future self",
    "section": "Hook configuration - Black",
    "text": "Hook configuration - Black\n  - repo: https://github.com/psf/black\n    rev: 22.10.0\n    hooks:\n      - id: black\n        types: [python]\n        additional_dependencies: ['click==8.0.4']\n        args: [\"--config pyproject.toml\"]\n\nNext we have a configuration section for the black formatter, its limited to python files via the types option and a required dependency click is pulled in.\nFinally we as users can pass additional arguments to black via the args line and here we‚Äôre telling black to explicitly look for its configuration in the pyproject.toml file which is the current recommended way of configuring your Python package if you are using setuptools/"
  },
  {
    "objectID": "index.html#hook-configuration---local",
    "href": "index.html#hook-configuration---local",
    "title": "Pre-commit : Protecting your future self",
    "section": "Hook Configuration - Local",
    "text": "Hook Configuration - Local\n  - repo: local\n    hooks:\n      -id: pytest\n      name: pytest\n      entry: pytest --cov\n      language: system\n\nBoth the pylint and pytest hooks are configured differently, the repo here is local, which means that rather than downloading a virtual environment to run the hook its going to use your existing local environment. This is because the environments that are available online do not include the packages that need to be installed to lint and test the code and so instead pre-commit uses the system where it is being run, i.e.¬†the virtual environment you have activated.\nFor Python projects there are other options, for example you could include a hook to run the static type checker mypy against your code base, there is an existing hook for this, or if you weren‚Äôt using pytest you could configure unittest and its extension nose you could configure a local hook to run tests using those."
  },
  {
    "objectID": "index.html#pre-commit-installation",
    "href": "index.html#pre-commit-installation",
    "title": "Pre-commit : Protecting your future self",
    "section": "pre-commit installation",
    "text": "pre-commit installation\n‚ù± git add .pre-commit-config\n‚ù± pre-commit --version\npre-commit 2.20.0\n‚ù± pre-commit install\npre-commit installed at .git/hooks/pre-commit\n\nNow that pre-commit is installed on your system and a configuration file has been added to your repository you can install the pre-commit hook in the repository.\nYou add the configuration file to the repository, check that pre-commit is available using the --version flag and then install it. This writes a bash script to .git/hook/pre-commit that runs pre-commit whenever you make a git commit, whether that is at the command line or through your IDE."
  },
  {
    "objectID": "index.html#check-existing-files",
    "href": "index.html#check-existing-files",
    "title": "Pre-commit : Protecting your future self",
    "section": "Check existing Files",
    "text": "Check existing Files\n‚ù± pre-commit run --all-files\n[INFO] Initializing environment for https://github.com/pre-commit/pre-commit-hooks.\n[INFO] Initializing environment for https://github.com/psf/black.\n[INFO] Initializing environment for https://github.com/pycqa/flake8.git.\n[INFO] Installing environment for https://github.com/pre-commit/pre-commit-hooks.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/psf/black.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/pycqa/flake8.git\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\nCheck Yaml.....................................................Passed\nFix End of Files...............................................Passed\nCheck for case conflicts.......................................Passed\nCheck docstring is first.......................................Failed\nTrim Trailing Whitespace.......................................Failed\n- hook id: trailing-whitespace\n- exit code: 1\n\nFiles were modified by this hook. Additional output:\n\nFixing sample.py\n\nblack..........................................................Failed\nreformatted sample.py\n\nAll done! ‚ú® üç∞ ‚ú®\n1 file reformatted.\nflake8.........................................................Failed\n- hook id: flake8\n- exit code: 1\n\nsample.py:1:1: D100 Missing docstring in public module\nsample.py:1:1: F401 'numpy as np' imported but unused\nsample.py:2:1: F401 'pandas as pd' imported but unused\nsample.py:7:36: F821 undefined name 'Union'\nsample.py:7:73: F821 undefined name 'List'\nsample.py:8:80: E501 line too long (87 > 79 characters)\nsample.py:9:80: E501 line too long (135 > 79 characters)\nsample.py:12:5: E722 do not use bare 'except'\n\npylint.........................................................Failed\n- hook id: pylint\n- exit code: 1\n\n************* Module python.sample\nsample.py:9:0: C0301: Line too long (135/120) (line-too-long)\nsample.py:1:0: C0114: Missing module docstring (missing-module-docstring)\nsample.py:7:35: E0602: Undefined variable 'Union' (undefined-variable)\nsample.py:7:72: E0602: Undefined variable 'List' (undefined-variable)\nsample.py:12:4: W0706: The except handler raises immediately (try-except-raise)\nsample.py:4:0: C0411: standard import \"from pathlib import Path\" should be placed before \"import numpy as np\" (wrong-import-order)\nsample.py:1:0: W0611: Unused numpy imported as np (unused-import)\nsample.py:2:0: W0611: Unused pandas imported as pd (unused-import)\n\n-------------------------------------\nYour code has been rated at -10.00/10\n\npytest.........................................................Failed\n================= test session starts =================\nplatform linux -- Python 3.7.11, pytest-7.1.1, pluggy-1.0.0\nrootdir: /home/neil/work/projects/pre-commit/assets/python\nplugins: hydra-core-1.2.0, regtest-1.5.0, cov-3.0.0\ncollected 0 items / 1 error\n\n======================= ERRORS ========================\n___________ ERROR collecting test_sample.py ___________\ntest_sample.py:1: in <module>\n    from .sample import find_files\nsample.py:7: in <module>\n    def find_and_load_files(file_path: Union[str, Path], file_type: str):\nE   NameError: name 'Union' is not defined\n================ short test summary info ===============\nERROR test_sample.py - NameError: name 'Union' is not defined\n!!!!!!!! Interrupted: 1 error during collection !!!!!!!!\n=================== 1 error in 0.49s ===================\n Who‚Äôs to Blame?"
  },
  {
    "objectID": "index.html#correcting-errors",
    "href": "index.html#correcting-errors",
    "title": "Pre-commit : Protecting your future self",
    "section": "Correcting Errors",
    "text": "Correcting Errors\nOriginal sample.py\nimport numpy as np\n\nfrom pathlib import Path\n\ndef find_files(file_path: Union[str, Path], file_ext: str) -> List:\n    \"\"\"Recursively find files of the stated type along the given file path.\"\"\"\n    # Short comment\n    try:\n        return list(Path(file_path).rglob(f\"*{file_ext}\"))\n    except:\n        raise\n``**\n\n**pylint errors**\n```{.bash}\n************* Module python.sample\nsample.py:9:0: C0301: Line too long (135/120) (line-too-long)\nsample.py:1:0: C0114: Missing module docstring (missing-module-docstring)\nsample.py:7:35: E0602: Undefined variable 'Union' (undefined-variable)\nsample.py:7:72: E0602: Undefined variable 'List' (undefined-variable)\nsample.py:12:4: W0706: The except handler raises immediately (try-except-raise)\nsample.py:4:0: C0411: standard import \"from pathlib import Path\" should be placed before \"import numpy as np\" (wrong-import-order)\nsample.py:1:0: W0611: Unused numpy imported as np (unused-import)\n\n-------------------------------------\nYour code has been rated at -10.00/10\nLinted\n\"\"\"Find files of a given type \"\"\"\nfrom pathlib import Path\nfrom typing import Union\n\n\ndef find_files(file_path: Union[str, Path], file_type: str) -> list:\n    \"\"\"Recursively find files of the stated type along the given file path.\"\"\"\n    return list(Path(file_path).rglob(f\"*{file_type}\"))"
  },
  {
    "objectID": "index.html#add-and-commit-changes",
    "href": "index.html#add-and-commit-changes",
    "title": "Pre-commit : Protecting your future self",
    "section": "Add and commit changes",
    "text": "Add and commit changes\ngit add sample.py\ngit commit -m \"Linting sample.py.\"\nCheck Yaml.....................................................Passed\nFix End of Files...............................................Passed\nCheck for case conflicts.......................................Passed\nCheck docstring is first.......................................Passed\nTrim Trailing Whitespace.......................................Passed\nblack..........................................................Passed\nflake8..........................................................Passed\npylint.........................................................Passed\npytest.........................................................Passed\n[INFO] Restored changes from /home/neil/.cache/pre-commit/patch1674045267-394193.\n[main 05b1568] Linting sample.py\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\nNow we add the files and commit them and because we have pre-commit configured and installed it runs as a hook and the checks we configured are run against only the files we are committing, in this case sample.py. There is no downloading of the environments as there was with the first manual run and as we‚Äôve corrected the linting errors the tests pass and the commit is made.\nThe [INFO] line here is saying changes have been restored is because pre-commit makes a git stash and only runs the linting on the files that are included in the commit then restores that stash afterwards.\nThis is much quicker and efficient than having to run black, flake8, pylint and pytest against the changed files manually, there is no cognitive overhead involved in thinking about what files to run against as there may be in larger changes. You might consider running linting and tests against the whole code base but this could be problematic if there are unlinted files and if its a large code base with lots of tests it might take a long time to run. With pre-commit the linting and tests run only against the files included in the commit and so are faster.\nThis all streamlines the process and frees up developer time.\nBut one point of friction is that its contingent on people using the tools locally, what if you have a contributor who hasn‚Äôt set themselves up with pre-commit as described and they make a pull request to have their bug fix or feature included. Is there a way to apply these checks against their pull request before it is committed to the master or main branch?"
  },
  {
    "objectID": "index.html#continuous-integrationdelivery-cicd",
    "href": "index.html#continuous-integrationdelivery-cicd",
    "title": "Pre-commit : Protecting your future self",
    "section": "Continuous Integration/Delivery (CI/CD)",
    "text": "Continuous Integration/Delivery (CI/CD)\n\nRuns hooks on GitHub/GitLab/etc. in response to specific tasks/actions.\nGitHub Actions (see also Actions Marketplace)\nGitLab Pipelines\nJenkins\n\n\nFortunately there is because many projects use Continuous Integration.\nThis involves running various checks such as linting, testing on Pull Requests before merging changes into main and master. Continuous delivery extends this and builds packages for release and tests that these work so they are ready to deploy.\nGitHub has Actions for performing these tasks, whilst GitLab has what it calls Pipelines\nAnother popular CI framework is Jenkins.\nFor the remainder of this talk I‚Äôm going to focus on GitHub Actions."
  },
  {
    "objectID": "index.html#github-actions",
    "href": "index.html#github-actions",
    "title": "Pre-commit : Protecting your future self",
    "section": "GitHub Actions",
    "text": "GitHub Actions\n\nActions are hooks that run under certain conditions e.g.¬†push to main branch or tag beginning with v.\nUseful for CI/CD.\nDefined in .github/workflows/*.yaml\nWrite your own .github/workflows/pre-commit.yaml or‚Ä¶\n\n\n\n‚Ä¶use pre-commit.ci\n\n\nGitHub Actions are hooks in that they are processes that run when certain conditions are met for example a push to the main branch, or a commit has a tag applied.\nAs mentioned they are useful for running Continuous Integration and Delivery and in a Git repository they are defined in YAML files that live in the .github/workflows/ directory.\nYou could write your own Action and save it in say pre-commit.yaml in this directory but there is an even easier service to use in the form of pre-commit.ci which is a CI extension to pre-commit."
  },
  {
    "objectID": "index.html#pre-commit.ci",
    "href": "index.html#pre-commit.ci",
    "title": "Pre-commit : Protecting your future self",
    "section": "pre-commit.ci",
    "text": "pre-commit.ci\n\nSupports GitHub but more to come in the future.\nZero configuration, just need .pre-commit-config.yaml.\nCorrects & commits some formatting issues automatically without need for developer to reformat.\nAutomatically updates .pre-commit-config.yaml for you (e.g.¬†new rev).\nFree for open source repositories (paid for version for private/organisation repositories).\n\n\nPre-commit.ci is a continuous integration service for the pre-commit framework.\nCurrently it only supports GitHub but apparently support is in development for other platforms such as GitLab and so forth.\nIts really easy to use, you don‚Äôt have to provide any specific configuration (although you can if you want to and I‚Äôll get to that shortly).\nIf the configured pre-commit hooks make simple formatting changes to your files pre-commit.ci will automatically fix the pull request.\nIt will also automatically keep your .pre-commit-config.yaml up-to-date when new revisions of configured hooks become available.\nIts free for open source repositories, there are paid for options for private and organisation repositories.\nIt really is worth using this over writing your own not just for the reasons described but it is also considerably faster because it caches the various environments that are used. If you wrote your own GitHub Action for this then on execution each runner would have to download all the hooks anew, setup and install any local environment and then run pre-commit. There is no such overhead with pre-commit.ci so if you can I would recommend using it."
  },
  {
    "objectID": "index.html#configuration-.pre-commit-config.yaml",
    "href": "index.html#configuration-.pre-commit-config.yaml",
    "title": "Pre-commit : Protecting your future self",
    "section": "Configuration (.pre-commit-config.yaml)",
    "text": "Configuration (.pre-commit-config.yaml)\n\nci:\n  autofix_prs: true\n  autofix_commit_msg: '[pre-commit.ci] Fixing issues with pre-commit'\n  autoupdate_schedule: weekly\n  autoupdate_commit_msg: '[pre-commit.ci] pre-commit automatically updated.'\n  skip: [pylint, pytest] # Optionally list ids of hooks to skip on CI\n\nIts not required but you can if you want configure pre-commit.ci with a ci: section in your .pre-commit-config.yaml, this example shows some explicit options to automatically fix pull requests and the message to add when doing so.\nThe update schedule is set to run weekly and as an example the pylint and pytest hooks are set to be skipped because if you remember these are configured to run in the local environments because of the dependency needs."
  },
  {
    "objectID": "index.html#pre-commit.ci-setup",
    "href": "index.html#pre-commit.ci-setup",
    "title": "Pre-commit : Protecting your future self",
    "section": "pre-commit.ci Setup",
    "text": "pre-commit.ci Setup\n\nSign-in with GitHub at https://pre-commit.ci\nGrant permission to your account.\n\n\n\nTo use pre-commit.ci just sign in with your GitHub credentials.\nYou can then follow the link to manage which repositories pre-commit.ci has access to on GitHub."
  },
  {
    "objectID": "index.html#manage-repos-for-pre-commit.ci",
    "href": "index.html#manage-repos-for-pre-commit.ci",
    "title": "Pre-commit : Protecting your future self",
    "section": "Manage Repos for pre-commit.ci",
    "text": "Manage Repos for pre-commit.ci\n\nGitLab pre-commit\n\nYou can provide pre-commit.ci access to all of your repositories or fine grained control to only specific repositories and I would advocate going with the fine-grained control so you know what is happening where and when.\nThat is all you need to do. Now when you push to master or main or make pull requests pre-commit.ci will run.\nIf you‚Äôre using GitLab there is a thread on StackOverflow linked here that shows how to setup and configure things.."
  },
  {
    "objectID": "index.html#pre-commit-github-action",
    "href": "index.html#pre-commit-github-action",
    "title": "Pre-commit : Protecting your future self",
    "section": "Pre-commit GitHub Action",
    "text": "Pre-commit GitHub Action\n\n\nWhen you make a Pull Request on your repository the GitHub Actions run and you can see at the bottom here that the pre-commit.ci job is listed. If we click on details‚Ä¶"
  },
  {
    "objectID": "index.html#pre-commit-pass",
    "href": "index.html#pre-commit-pass",
    "title": "Pre-commit : Protecting your future self",
    "section": "Pre-commit Pass",
    "text": "Pre-commit Pass\n\nPass\n\nYou get an overview for each repository you have enabled pre-commit.ci for showing the success and failures of historical runs and as you see here you can add a badge to your repository to indicate success."
  },
  {
    "objectID": "index.html#pre-commit-pass-1",
    "href": "index.html#pre-commit-pass-1",
    "title": "Pre-commit : Protecting your future self",
    "section": "Pre-commit Pass",
    "text": "Pre-commit Pass\n\nPass\n\nWe are taken to the job and can see exactly which checks were carried out and in this example we see they all pass and because we disabled pylint from running under CI it shows as Skipped as were a few other steps but all the other checks passed. Sometimes jobs fail though‚Ä¶"
  },
  {
    "objectID": "index.html#pre-commit-fail",
    "href": "index.html#pre-commit-fail",
    "title": "Pre-commit : Protecting your future self",
    "section": "Pre-commit Fail",
    "text": "Pre-commit Fail\n\nFail\n\nHere you can see the pre-commit found trailing white spaces across a number of files and it went ahead and fixed them for us and automatically pushed them back to the branch for inclusion in the pull request and we can click through and look at that."
  },
  {
    "objectID": "index.html#summary",
    "href": "index.html#summary",
    "title": "Pre-commit : Protecting your future self",
    "section": "Summary",
    "text": "Summary\n\n\n‚úîÔ∏è pre-commit is useful for automating repetitive tasks.\n‚úîÔ∏è Helps keep git history clean (no more ‚Äúlinting code‚Äù commit messages).\n‚úîÔ∏è Improves code quality by ensuring style guides are adhered to.\n‚úîÔ∏è Automates running test suites and ensures they pass.\n‚úîÔ∏è Integrates with CI/CD on GitHub and others.\n‚úîÔ∏è Frees up developer time.\n\n\n\nIn this talk I‚Äôve hopefully demonstrated how using pre-commit can help automate running repetitive tasks.\nBy using it you help keep your git history clean, it improves the code quality by ensuring style guides are adhered to, automates running test suites and ensures they pass , integrates into CI/CD pipelines and all of this helps free up developer time by pushing the detection of errors as far ‚Äúleft‚Äù or early into the development cycle as possible.\nThis is important because it is developer time that is often the most expensive component of a project and you don‚Äôt want people sitting around waiting for tests to fail on CI/CD pipelines when they could have been caught earlier in the development cycle‚Ä¶.i.e. pre-commit."
  },
  {
    "objectID": "index.html#alternatives",
    "href": "index.html#alternatives",
    "title": "Pre-commit : Protecting your future self",
    "section": "Alternatives",
    "text": "Alternatives\n\nMegalinter.io - comparable, lots of languages, lots of tools.\nCodacy - only works with GitHub repos, not locally.\nNo doubt many others I‚Äôm not aware of!"
  },
  {
    "objectID": "index.html#bonus---linting-with-ide",
    "href": "index.html#bonus---linting-with-ide",
    "title": "Pre-commit : Protecting your future self",
    "section": "Bonus - Linting with IDE",
    "text": "Bonus - Linting with IDE\nPopular IDEs have tools to run linting automatically on file save‚Ä¶\n\nEmacs : blacken / Flycheck / Pylint & Flymake\nVSCode : Python\nPyCharm : black / Mypy / flake8\nRStudio : lintr\n\n\nMany popular Integrated Development Environments support linting of code on the fly or on saving files, Emacs has blacken and flycheck modes, the later of which will run flake8.\nVSCode has a Python module for linting.\nPyCharm has plugins for black, mypy and flake8\nRStudio has support for the lintr package (as does Emacs).\nUsing these tools is sensible as it can highlight quickly and early on problems with your code. Applying black automatically also takes out some mental overhead in thinking about whether you are using the correct formatting whilst writing code allowing you to focus on the problem you are trying to solve."
  },
  {
    "objectID": "index.html#view-these-slides-1",
    "href": "index.html#view-these-slides-1",
    "title": "Pre-commit : Protecting your future self",
    "section": "View these slides‚Ä¶",
    "text": "View these slides‚Ä¶\n\nns-rse.github.io/pre-commit/\n\nHere‚Äôs the QR code again in case you missed it, these slides have lots of links in to the resources and tools I‚Äôve talked about so please do take the time to check them out.\nAlso they‚Äôre written in RevealJS so if you view them hit ‚Äòs‚Äô and you can see the speaker notes I wrote and probably failed abysmally to follow today!\n\n\n\nns-rse.github.io/pre-commit/"
  }
]